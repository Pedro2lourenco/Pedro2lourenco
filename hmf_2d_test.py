# -*- coding: utf-8 -*-
"""HMF-2D - test

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_md4MD1wXu5r0ccimfJyPh_U4cEcoURo
"""

import matplotlib.pyplot as plt
import numpy as np
from numpy import sin,cos,sqrt,pi,square,log
import scipy as sp
import time


E_in = .498

h = 0.5
N = 5
x = np.zeros(N)
y = np.zeros(N)
px = np.zeros(N)
py = np.zeros(N)

n = 4

c1 = c2 = 1
c = -1
d = 1

lyap_num = 2*N


#w = [np.random.uniform() for i in range(4*N)]
w = 2*np.random.randint(4*N)-np.ones(4*N)
w = w/np.dot(w,w)

def ortho(v):

  Q = v
  Q = v - float(((np.dot(Q,v))/(np.dot(v,v))))*v

  return Q/float(np.linalg.norm(Q))

def evolveQ(X,Y,PX,PY,delta):
    
    X += PX*delta
    Y += PY*delta
    
    return(X,Y)

def evolveP(X,Y,PX,PY,delta):
    
    M1x = np.sum(np.cos(X))/N
    M1y = np.sum(np.sin(X))/N
    M2x = np.sum(np.cos(Y))/N
    M2y = np.sum(np.sin(Y))/N
    Ppx = np.sum(np.cos(X+Y))/N
    Ppy = np.sum(np.sin(X+Y))/N
    Pmx = np.sum(np.cos(X-Y))/N
    Pmy = np.sum(np.sin(X-Y))/N
    
    Fx = c*((M1y*np.cos(X))-(M1x*np.sin(X)))+0.5*d*((Ppy*np.cos(X+Y))-(Ppx*np.sin(X+Y))+(Pmy*np.cos(X-Y))-(Pmx*np.sin(X-Y)))
    
    Fy = c*((M2y*np.cos(Y))-(M2x*np.sin(Y)))+0.5*d*((Ppy*np.cos(X+Y))-(Ppx*np.sin(X+Y))-(Pmy*np.cos(X-Y))+(Pmx*np.sin(X-Y)))
    
    PX += Fx*delta
    PY += Fy*delta
    
    return(PX,PY)

s = 1/(4-4**(1/3))

delta1 = h*s

delta2 = 0.5*(h*s)

delta3 = 0.5*h*(1-(3*s))

delta4 = (1-(4*s))*h

def evolvedQ(dX,dY,dPx,dPy,delta):
    dX += dPx*delta 
    dY += dPy*delta 
    
    return(dX,dY)

def evolvedP(X,Y,dX,dY,dPx,dPy,delta):
    
    M1x = np.sum(np.cos(X))/N
    M1y = np.sum(np.sin(X))/N
    M2x = np.sum(np.cos(Y))/N
    M2y = np.sum(np.sin(Y))/N
    Ppx = np.sum(np.cos(X+Y))/N
    Ppy = np.sum(np.sin(X+Y))/N
    Pmx = np.sum(np.cos(X-Y))/N
    Pmy = np.sum(np.sin(X-Y))/N
    
    dM1x = np.sum(dX*-np.sin(X))/N
    dM1y = np.sum(dX*np.cos(X))/N
    dM2x = np.sum(dY*-np.sin(Y))/N
    dM2y = np.sum(dY*np.cos(Y))/N
    dPpx = np.sum(-np.sin(X+Y)*(dX+dY))/N
    dPpy = np.sum(np.cos(X+Y)*(dX+dY))/N
    dPmx = np.sum(-np.sin(X-Y)*(dX-dY))/N
    dPmy = np.sum(np.cos(X-Y)*(dX-dY))/N
    
    dFx = c*((dM1y*np.cos(X)-M1y*np.sin(X)*dX)-(dM1x*np.sin(X)+M1x*np.cos(X)*dX))+0.5*d*((dPpy*np.cos(X+Y)-Ppy*np.sin(X+Y)*dX)-(dPpx*np.sin(X+Y)+Ppx*np.cos(X+Y)*dX)+(dPmy*cos(X-Y)-Pmy*sin(X-Y)*dX)-(dPmx*np.sin(X-Y)+Pmx*np.cos(X-Y)*dX))
    dFy = c*((dM2y*np.cos(Y)-M2y*np.sin(Y)*dY)-(dM2x*np.sin(Y)+M2x*np.cos(Y)*dY))+0.5*d*((dPpy*np.cos(X+Y)-Ppy*np.sin(X+Y)*dY)-(dPpx*np.sin(X+Y)+Ppx*np.cos(X+Y)*dY)-(dPmy*cos(X-Y)+Pmy*sin(X-Y)*dY)+(dPmx*np.sin(X-Y)-Pmx*np.cos(X-Y)*dY))
    
    dPx += dFx*delta
    dPy += dFy*delta
    
    return(dPx,dPy)

def Suzuki4_linear(X,Y,dX,dY,dPx,dPy):
    
    evolvedQ(dX,dY,dPx,dPy,delta2)
    evolvedP(X,Y,dX,dY,dPx,dPy,delta1)
    evolvedQ(dX,dY,dPx,dPy,delta1)
    evolvedP(X,Y,dX,dY,dPx,dPy,delta1)
    evolvedQ(dX,dY,dPx,dPy,delta3)
    evolvedP(X,Y,dX,dY,dPx,dPy,delta4)
    evolvedQ(dX,dY,dPx,dPy,delta3)
    evolvedP(X,Y,dX,dY,dPx,dPy,delta1)
    evolvedQ(dX,dY,dPx,dPy,delta1)
    evolvedP(X,Y,dX,dY,dPx,dPy,delta1)
    evolvedQ(dX,dY,dPx,dPy,delta2)
    
    return(dX,dY,dPx,dPy)
    
    
def Suzuki4(X,Y,PX,PY):
    
    evolveQ(X,Y,PX,PY,delta2)
    evolveP(X,Y,PX,PY,delta1)
    evolveQ(X,Y,PX,PY,delta1)
    evolveP(X,Y,PX,PY,delta1)
    evolveQ(X,Y,PX,PY,delta3)
    evolveP(X,Y,PX,PY,delta4)
    evolveQ(X,Y,PX,PY,delta3)
    evolveP(X,Y,PX,PY,delta1)
    evolveQ(X,Y,PX,PY,delta1)
    evolveP(X,Y,PX,PY,delta1)
    evolveQ(X,Y,PX,PY,delta2)
    
    return(X,Y,PX,PY)
    
def K(PX,PY):
    return 0.5*np.sum(np.square(PX)+np.square(PY))/N

def V(X,Y):
    
    M1x = np.sum(np.cos(X))/N
    M1y = np.sum(np.sin(X))/N
    M2x = np.sum(np.cos(Y))/N
    M2y = np.sum(np.sin(Y))/N
    Ppx = np.sum(np.cos(X+Y))/N
    Ppy = np.sum(np.sin(X+Y))/N
    Pmx = np.sum(np.cos(X-Y))/N
    Pmy = np.sum(np.sin(X-Y))/N
    
    
    M1 = np.sqrt(np.square(M1x)+np.square(M1y))
    M2 = np.sqrt(np.square(M2x)+np.square(M2y))
    
    Pp = np.sqrt(np.square(Ppx)+np.square(Ppy))
    Pm = np.sqrt(np.square(Pmx)+np.square(Pmy))
    
    
    #return (2-((M1x*np.cos(X))+(M1y*np.sin(X)))-((M2x*np.cos(Y))+(M2y*np.sin(Y)))-0.5*(2-((Ppx*np.cos(X+Y))+(Ppy*np.sin(X+Y)))-((Pmx*np.cos(X-Y))+(Pmy*np.sin(X-Y)))))
    return 0.5*c*(2-np.square(M1)-np.square(M2)) + 0.25*d*(2-np.square(Pp)-np.square(Pm))
    
def H(K,V):
    return (K+V)


def waterbag(X,Y,PX,PY):
    
    deltax = deltay = 2*n*np.pi
    deltapy = 1e-5
    
    M1x = (np.sin(deltax)/deltax)
    M1y = ((1.-np.cos(deltax))/deltax)
    M1_2 = np.square(M1x) + np.square(M1y)
    
    M2x = (np.sin(deltay)/deltay)
    M2y = ((1.-np.cos(deltay))/deltay)
    M2_2 = np.square(M2x) + np.square(M2y)
    
    a = deltax*deltay
    
    P_plusx = (1./a)*(np.sin(deltax)*np.sin(deltay) - (1.-np.cos(deltax))*(1.-np.cos(deltay)))
    P_plusy = (1./a)*((1.-np.cos(deltax))*np.sin(deltay)+(1.-np.cos(deltay))*np.sin(deltax))
    P_plus2 = np.square(P_plusx) + np.square(P_plusy)
    
    P_minusx = (1./a)*(np.sin(deltax)*np.sin(deltay) + (1.-np.cos(deltax))*(1.-np.cos(deltay)))
    P_minusy = (1./a)*((1.-np.cos(deltax))*np.sin(deltay) - (1.-np.cos(deltay))*np.sin(deltax))
    P_minus2 = np.square(P_minusx) + np.square(P_minusy)
    
    U1 = 0.5*c*(2. - M1_2 - M2_2)
    U2 = 0.25*d*(2. - P_plus2 - P_minus2)
    
    alpha = 1./24.*np.square(deltapy) + U1 + U2

    deltapx = np.sqrt(24.*(E_in - alpha))
    
    for i in range(N):
        X = np.random.rand(N)*(deltax)
        Y = np.random.rand(N)*(deltay)
        PX = (2.*np.random.rand(N) - np.ones(N))*(0.5*deltapx)
        PY = (2.*np.random.rand(N) - np.ones(N))*(0.5*deltapy)


    return (X,Y,PX,PY)



x,y,px,py = waterbag(x,y,px,py)



L = []
last = []

MSD = 0

r0x = []
r0y = []

lamb = 0

exp = []
    
for r in range(N):
    r0x.append(x[r])
    r0y.append(y[r])

time = np.arange(0,100,h)

for k in range(len(w)):

  print(k)

  for i in range(1,len(time)+1):

    #print(i)

    x,y,px,py = Suzuki4(x, y, px, py)
    
    w[0:N],w[N:2*N],w[2*N:3*N],w[3*N:4*N] = Suzuki4_linear(x, y, w[0:N], w[N:2*N], w[2*N:3*N], w[3*N:4*N])

    lamb += log(np.linalg.norm(w))
    
    coisa = lamb/(float(i)*h)

    L.append(coisa)

    w = (1/(np.sqrt(np.dot(w,w))))*w
    
    ##periodic boundary conditions
    for jj in range(N):
        if( np.abs(x[jj]) > 2*n*np.pi):
            x[jj] -= np.sign(x[jj])*2.*n*np.pi
        if( np.abs(y[jj]) > 2*n*np.pi):
            y[jj] -= np.sign(y[jj])*2.*n*np.pi

  last = L[-1]

  exp.append(last)
  
  w = ortho(w)

  print(np.linalg.norm(w))

I = np.arange(0,len(w),1)

print(len(I),len(exp))
print(I,exp)
plt.scatter(I,exp,color='k')
plt.plot(I,exp,color='k')
plt.show()